<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Snow Globe</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        touch-action: none;
    }
    canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }
</style>
</head>
<body>
<canvas id="globe"></canvas>

<script>
/* -------------------------
   CONFIG
--------------------------*/

// Background and object via IPFS CIDs
const BG_IMG = "https://ipfs.io/ipfs/bafybeiepec62olvujw52tbntuaryuyoiofjjz7s246hmethykvgfbnls34";
const OBJ_IMG = "https://ipfs.io/ipfs/bafybeihnyoiyxsrzicx23funhiiwijfl55twsls6bsn4ypc2ybxyh7ucc4";

// Particle config
const SNOW_COUNT = 400;
const SPARKLE_COUNT = 60;

let canvas = document.getElementById("globe");
let ctx = canvas.getContext("2d");

let W, H, CX, CY, R; // dynamic globe size
let bg = new Image();
let obj = new Image();

// physics state
let objState = {
    x: 0, y: 0,
    vx: 0, vy: 0,
    radius: 40,
    rotation: 0,
    angularVelocity: 0
};

let snow = [];
let sparkles = [];

/* -------------------------
    RESIZE HANDLING
--------------------------*/
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    W = canvas.width;
    H = canvas.height;

    // Globe radius = 42% of min dimension
    R = Math.min(W, H) * 0.42;
    CX = W / 2;
    CY = H / 2;

    // Rescale object radius dynamically
    objState.radius = R * 0.22; // fits neatly inside
}
window.addEventListener("resize", resize);
resize();

/* -------------------------
    INIT SNOW + SPARKLES
--------------------------*/
function initParticles() {
    snow = [];
    for (let i = 0; i < SNOW_COUNT; i++) {
        let angle = Math.random() * Math.PI * 2;
        let dist = Math.random() * R * 0.95;
        snow.push({
            x: CX + Math.cos(angle) * dist,
            y: CY + Math.sin(angle) * dist,
            vx: (Math.random() - 0.5) * 0.4,
            vy: (Math.random() - 0.5) * 0.4,
            size: Math.random() * 2 + 1
        });
    }
}

function initSparkles() {
    sparkles = [];
    for (let i = 0; i < SPARKLE_COUNT; i++) sparkles.push({ x: 0, y: 0, life: 0 });
}
initParticles();
initSparkles();

/* -------------------------
    SHAKER (TOUCH + MOUSE)
--------------------------*/
let lastX = null, lastY = null;

function triggerShake() {
    // Kick object
    objState.vx += (Math.random() - 0.5) * 4;
    objState.vy += (Math.random() - 0.5) * 4;
    objState.angularVelocity += (Math.random() - 0.5) * 0.1;

    // Sparkles burst
    for (let s of sparkles) {
        s.x = CX + (Math.random() - 0.5) * R * 0.4;
        s.y = CY + (Math.random() - 0.5) * R * 0.4;
        s.life = 1;
    }
}

// touch + swipe
canvas.addEventListener("touchmove", e => {
    let t = e.touches[0];
    if (lastX !== null) {
        let dx = t.clientX - lastX;
        let dy = t.clientY - lastY;
        if (Math.abs(dx) + Math.abs(dy) > 8) triggerShake();
    }
    lastX = t.clientX;
    lastY = t.clientY;
});
canvas.addEventListener("touchend", () => { lastX = lastY = null; });

// Mouse dragging
canvas.addEventListener("mousemove", e => {
    if (e.buttons === 1) triggerShake();
});

/* -------------------------
    PHYSICS LOOP
--------------------------*/
function updatePhysics() {
    // Update object
    let o = objState;

    // Gravity
    o.vy += 0.15;

    // Apply velocities
    o.x += o.vx;
    o.y += o.vy;

    // Angular
    if (Math.abs(o.vx) + Math.abs(o.vy) < 0.05) {
        o.angularVelocity *= 0.9;
    }
    o.rotation += o.angularVelocity;

    // Damping
    o.vx *= 0.995;
    o.vy *= 0.995;
    o.angularVelocity *= 0.99;

    // Boundary collision (circular)
    let dx = o.x - CX;
    let dy = o.y - CY;
    let dist = Math.sqrt(dx * dx + dy * dy);
    let maxDist = R - o.radius * 0.92;

    if (dist > maxDist) {
        let nx = dx / dist;
        let ny = dy / dist;

        o.x = CX + nx * maxDist;
        o.y = CY + ny * maxDist;

        let dot = o.vx * nx + o.vy * ny;
        o.vx -= dot * nx * 1.6;
        o.vy -= dot * ny * 1.6;

        // Slide effect
        o.vx *= 0.8;
        o.vy *= 0.8;
    }

    // Snow particles
    for (let p of snow) {
        p.vy += 0.03; 
        p.x += p.vx;
        p.y += p.vy;

        let dx = p.x - CX;
        let dy = p.y - CY;
        let d = Math.sqrt(dx * dx + dy * dy);

        if (d > R * 0.95) {
            let nx = dx / d;
            let ny = dy / d;
            p.x = CX + nx * R * 0.95;
            p.y = CY + ny * R * 0.95;
            p.vx *= -0.4;
            p.vy *= -0.4;
        }
    }

    // Sparkles fade
    for (let s of sparkles) {
        if (s.life > 0) s.life -= 0.02;
    }
}

/* -------------------------
    RENDER LOOP
--------------------------*/
function draw() {
    ctx.clearRect(0, 0, W, H);

    // Background
    ctx.drawImage(bg, 0, 0, W, H);

    // Globe mask
    ctx.save();
    ctx.beginPath();
    ctx.arc(CX, CY, R, 0, Math.PI * 2);
    ctx.clip();

    // Snow particles
    ctx.fillStyle = "white";
    for (let p of snow) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    }

    // Draw object inside globe
    let o = objState;
    ctx.save();
    ctx.translate(o.x, o.y);
    ctx.rotate(o.rotation);
    ctx.drawImage(obj, -o.radius, -o.radius, o.radius * 2, o.radius * 2);
    ctx.restore();

    // Sparkles
    ctx.globalCompositeOperation = "lighter";
    for (let s of sparkles) {
        if (s.life > 0) {
            ctx.fillStyle = `rgba(255,255,255,${s.life})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, 2 + 2 * s.life, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    ctx.globalCompositeOperation = "source-over";

    ctx.restore();

    // Glass glare
    let g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, "rgba(255,255,255,0.22)");
    g.addColorStop(0.4, "rgba(255,255,255,0.05)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(CX, CY, R, 0, Math.PI * 2);
    ctx.fill();

    // Chromatic rim refraction
    ctx.lineWidth = R * 0.03;
    ctx.strokeStyle = "rgba(120,180,255,0.5)";
    ctx.beginPath();
    ctx.arc(CX, CY, R * 1.01, 0, Math.PI * 2);
    ctx.stroke();

    ctx.lineWidth = R * 0.015;
    ctx.strokeStyle = "rgba(180,120,255,0.4)";
    ctx.beginPath();
    ctx.arc(CX, CY, R * 1.04, 0, Math.PI * 2);
    ctx.stroke();
}

/* -------------------------
    MAIN LOOP
--------------------------*/
function loop() {
    updatePhysics();
    draw();
    requestAnimationFrame(loop);
}
bg.onload = () => {
    obj.onload = () => {
        // center object initially
        objState.x = CX;
        objState.y = CY - R * 0.3;
        loop();
    };
    obj.src = OBJ_IMG;
};
bg.src = BG_IMG;

</script>
</body>
</html>
