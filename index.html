<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snow Globe NFT</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        background: #000;
    }
    #globeWrapper {
        position: relative;
        width: 90vw;
        height: 90vw;
        max-width: 500px;
        max-height: 500px;
        border-radius: 50%;
        overflow: hidden;
        border: 10px solid rgba(255,255,255,0.4);
        box-shadow: 0 0 40px rgba(255,255,255,0.3) inset;
        background: transparent;
    }
    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</head>
<body>

<div id="globeWrapper">
    <canvas id="globeCanvas"></canvas>
</div>

<script>
// =======================
// CONFIG
// =======================
const PARTICLE_COUNT = 400;
const SHAKE_FORCE = 2.5;
const SWIPE_FORCE = 3.0;
const GRAVITY = 0.05;
const HEAVY_GRAVITY = 0.2; // for snow object

let canvas = document.getElementById("globeCanvas");
let ctx = canvas.getContext("2d");
let W, H, globeRadius;

function resizeCanvas() {
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    W = canvas.width;
    H = canvas.height;
    globeRadius = W/2 - 10; // radius minus border
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// =======================
// BACKGROUND IMAGE
// =======================
let bgScene = new Image();
bgScene.src = "https://ipfs.io/ipfs/bafybeiepec62olvujw52tbntuaryuyoiofjjz7s246hmethykvgfbnls34";

// =======================
// PARTICLE CLASS
// =======================
class Particle {
    constructor() { this.reset(); }
    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = 0;
        this.vy = 0;
        this.size = Math.random()*2+1;
        this.settled = false;
    }
    applyForce(fx, fy) { this.vx += fx; this.vy += fy; this.settled=false; }
    update() {
        if(!this.settled){
            this.vy += GRAVITY;
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.98;
            this.vy *= 0.98;
        }
        // collision with bottom
        if(this.y>H-this.size){ this.y=H-this.size; this.vx*=0.4; this.vy=0; if(Math.abs(this.vx)<0.01)this.settled=true;}
        if(this.x<0){ this.x=0; this.vx*=-0.5;}
        if(this.x>W){ this.x=W; this.vx*=-0.5;}
    }
    draw(){
        ctx.fillStyle="white";
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
        ctx.fill();
    }
}

// =======================
// SNOW OBJECT CLASS
// =======================
class SnowObject {
    constructor(img){
        this.img = img;
        this.width = img.width*0.25;
        this.height = img.height*0.25;
        this.reset();
    }
    reset(){
        // start near top in random position within circle
        let angle = Math.random()*Math.PI*2;
        let r = Math.random()*globeRadius*0.7;
        this.x = W/2 + r*Math.cos(angle);
        this.y = H/2 + r*Math.sin(angle) - globeRadius*0.3;
        this.vx = 0; this.vy = 0;
        this.settled=false;
        this.angle = Math.random()*Math.PI*2;
        this.angularVelocity = (Math.random()-0.5)*0.02;
    }
    applyForce(fx, fy){
        this.vx += fx;
        this.vy += fy;
        this.settled=false;
        this.angularVelocity += (Math.random()-0.5)*0.05;
    }
    update(){
        if(!this.settled){
            this.vy += HEAVY_GRAVITY;
            this.x += this.vx;
            this.y += this.vy;
            this.vx*=0.98; this.vy*=0.98;
            this.angle += this.angularVelocity;
        }
        // boundary check: keep inside circle
        let dx = this.x - W/2;
        let dy = this.y - H/2;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if(dist + Math.max(this.width,this.height)/2 > globeRadius){
            let angle = Math.atan2(dy,dx);
            let overlap = dist + Math.max(this.width,this.height)/2 - globeRadius;
            this.x -= Math.cos(angle)*overlap;
            this.y -= Math.sin(angle)*overlap;
            this.vx*=-0.5;
            this.vy*=-0.5;
            this.angularVelocity*=-0.5;
            if(Math.abs(this.vx)<0.01 && Math.abs(this.vy)<0.01) this.settled=true;
        }
    }
    draw(){
        ctx.save();
        ctx.translate(this.x,this.y);
        ctx.rotate(this.angle);
        ctx.drawImage(this.img,-this.width/2,-this.height/2,this.width,this.height);
        ctx.restore();
    }
}

// =======================
// CREATE PARTICLES
// =======================
let particles=[];
for(let i=0;i<PARTICLE_COUNT;i++) particles.push(new Particle());

// =======================
// LOAD SNOW OBJECT IMAGE
// =======================
let snowImg=new Image();
snowImg.src="https://ipfs.io/ipfs/bafybeigftb6innx7vd42qicjuhntoxlegfup2rpqu3flruilqinnvw2nae";
let snowObject=null;
snowImg.onload=()=>{
    snowObject = new SnowObject(snowImg);
}

// =======================
// SWIPE DETECTION
// =======================
let lastX = null;
let swipeEnergy = 0;
canvas.addEventListener("touchmove", e=>{
    let touch=e.touches[0];
    if(lastX!==null){
        let dx=touch.clientX-lastX;
        swipeEnergy+=Math.abs(dx)*0.01;
        if(swipeEnergy>1) triggerSwirl(SWIPE_FORCE);
    }
    lastX=touch.clientX;
});
canvas.addEventListener("touchend",()=>{lastX=null; swipeEnergy=0;});

// =======================
// ACCELEROMETER / SHAKE
// =======================
function handleMotion(e){
    let shake = Math.abs(e.acceleration.x||0)+Math.abs(e.acceleration.y||0)+Math.abs(e.acceleration.z||0);
    if(shake>22) triggerSwirl(SHAKE_FORCE);
}
if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
    DeviceMotionEvent.requestPermission()
        .then(response=>{if(response==='granted')window.addEventListener('devicemotion',handleMotion);})
        .catch(console.error);
}else{
    window.addEventListener('devicemotion',handleMotion);
}

// =======================
// SWIRL EFFECT
// =======================
function triggerSwirl(force){
    particles.forEach(p=>{
        let angle=Math.random()*Math.PI*2;
        p.vx+=Math.cos(angle)*force;
        p.vy+=Math.sin(angle)*force;
        p.settled=false;
    });
    if(snowObject) snowObject.applyForce((Math.random()-0.5)*force*5,-Math.random()*force*2);
}

// =======================
// MAIN LOOP
// =======================
function loop(){
    ctx.clearRect(0,0,W,H);
    // draw scene background
    ctx.drawImage(bgScene,0,0,W,H);
    // draw snow object beneath particles
    if(snowObject){ snowObject.update(); snowObject.draw(); }
    // draw particles on top
    particles.forEach(p=>{ p.update(); p.draw(); });
    requestAnimationFrame(loop);
}
bgScene.onload = loop;

</script>
</body>
</html>
