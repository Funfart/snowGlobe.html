<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snow Globe App</title>

<style>
    body {
        margin: 0;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }

    #globeWrapper {
        position: relative;
        width: 90vw;
        height: 90vw;
        max-width: 500px;
        max-height: 500px;
        border-radius: 50%;
        overflow: hidden;
        border: 10px solid rgba(255,255,255,0.4);
        box-shadow: 0 0 40px rgba(255,255,255,0.3) inset;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }
</style>
</head>
<body>

<div id="globeWrapper">
    <canvas id="globeCanvas"></canvas>
</div>

<script>
// ==========================================================
// CONFIG
// ==========================================================
const PARTICLE_COUNT = 500;  // finite amount
const SHAKE_FORCE = 2.5;
const SWIPE_FORCE = 3.0;
const SETTLE_SPEED = 0.03;
const GRAVITY = 0.05;

let canvas = document.getElementById("globeCanvas");
let ctx = canvas.getContext("2d");

canvas.width = canvas.offsetWidth;
canvas.height = canvas.offsetHeight;

let W = canvas.width;
let H = canvas.height;

// ==========================================================
// LOAD BACKGROUND IMAGE
// ==========================================================
let background = new Image();
background.src = "image1.png";

// ==========================================================
// PARTICLE CLASS
// ==========================================================
class Particle {
    constructor() {
        this.reset();
    }

    reset() {
        this.x = Math.random() * W;
        this.y = Math.random() * H;
        this.vx = 0;
        this.vy = 0;
        this.size = Math.random() * 2 + 1; // glitter size
        this.settled = false;
    }

    applyForce(fx, fy) {
        this.vx += fx;
        this.vy += fy;
        this.settled = false;
    }

    update() {
        if (!this.settled) {
            this.vy += GRAVITY;

            // movement
            this.x += this.vx;
            this.y += this.vy;

            // drag
            this.vx *= 0.98;
            this.vy *= 0.98;
        }

        // collision with bottom (settling)
        if (this.y > H - this.size) {
            this.y = H - this.size;
            this.vx *= 0.4;
            this.vy = 0;

            // particle settles gradually
            if (Math.abs(this.vx) < 0.01) {
                this.settled = true;
            }
        }

        // walls
        if (this.x < 0) { this.x = 0; this.vx *= -0.5; }
        if (this.x > W) { this.x = W; this.vx *= -0.5; }
    }

    draw() {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ==========================================================
// CREATE PARTICLES
// ==========================================================
let particles = [];
for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push(new Particle());
}

// ==========================================================
// SWIPE DETECTION
// ==========================================================
let lastX = null;
let swipeEnergy = 0;

canvas.addEventListener("touchmove", e => {
    let touch = e.touches[0];
    if (lastX !== null) {
        let dx = touch.clientX - lastX;

        // repeated swipe left/right
        swipeEnergy += Math.abs(dx) * 0.01;

        if (swipeEnergy > 1) triggerSwirl(SWIPE_FORCE);
    }
    lastX = touch.clientX;
});

canvas.addEventListener("touchend", () => {
    lastX = null;
    swipeEnergy = 0;
});

// ==========================================================
// SHAKE DETECTION (ACCELEROMETER)
// ==========================================================
if (window.DeviceMotionEvent) {
    window.addEventListener("devicemotion", e => {
        let shake =
            Math.abs(e.acceleration.x) +
            Math.abs(e.acceleration.y) +
            Math.abs(e.acceleration.z);

        if (shake > 22) {  // threshold
            triggerSwirl(SHAKE_FORCE);
        }
    });
}

// ==========================================================
// SWIRL EFFECT
// ==========================================================
function triggerSwirl(force) {
    particles.forEach(p => {
        let angle = Math.random() * Math.PI * 2;
        p.vx += Math.cos(angle) * force;
        p.vy += Math.sin(angle) * force;
        p.settled = false;
    });
}

// ==========================================================
// MAIN ANIMATION LOOP
// ==========================================================
function loop() {
    ctx.clearRect(0, 0, W, H);

    // background
    ctx.drawImage(background, 0, 0, W, H);

    // update particles
    particles.forEach(p => {
        p.update();
        p.draw();
    });

    requestAnimationFrame(loop);
}

background.onload = loop;

</script>
</body>
</html>
