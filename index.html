<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
<title>Snow Globe â€” Tutorial + Flip</title>
<style>
  :root{ --bg:#041022; --hint:#dfefff; }
  html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:system-ui,Arial;}
  #globeWrap{width:92vw;max-width:520px;aspect-ratio:1/1;border-radius:50%;overflow:hidden;border:10px solid rgba(255,255,255,0.12);box-shadow:0 20px 50px rgba(0,0,0,0.6) inset;position:relative;background:#02101a}
  canvas{display:block;width:100%;height:100%;}
  /* Tutorial overlay */
  #tutorial{
    position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;
    pointer-events:auto;
  }
  .tcard{
    width:70%;max-width:320px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    border-radius:14px;padding:18px;text-align:center;color:var(--hint);backdrop-filter: blur(6px);
    box-shadow:0 6px 18px rgba(0,0,0,0.6);
  }
  .title{font-size:18px;margin-bottom:8px}
  .hint{font-size:13px;opacity:0.95}
  /* hand swipe animation */
  .hand{
    width:72px;height:72px;margin:12px auto 6px;position:relative;
  }
  .finger{
    width:18px;height:26px;border-radius:12px;background:rgba(255,255,255,0.9);position:absolute;left:27px;top:8px;transform-origin:center top;
    animation: tap 1000ms infinite;
    box-shadow:0 1px 0 rgba(0,0,0,0.15);
  }
  .finger::after{content:'';position:absolute;left:-26px;top:24px;width:60px;height:10px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));}
  @keyframes tap{
    0%{transform:translateX(-20px) rotate(-12deg);opacity:0.92}
    30%{transform:translateX(-2px) rotate(-4deg);opacity:1}
    60%{transform:translateX(20px) rotate(6deg);opacity:0.96}
    100%{transform:translateX(-20px) rotate(-12deg);opacity:0.92}
  }
  /* Confetti layer */
  #confetti{position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;overflow:hidden}
  .confetti-piece{position:absolute;width:8px;height:12px;border-radius:2px;opacity:0.95;transform-origin:center center}
  /* small UX hint */
  #miniHint{position:absolute;left:12px;bottom:12px;color:var(--hint);font-size:12px;opacity:0.9}
</style>
</head>
<body>
  <div id="globeWrap" role="img" aria-label="Interactive snow globe">
    <canvas id="globe"></canvas>

    <div id="tutorial" aria-hidden="false">
      <div class="tcard" id="tcard">
        <div class="hand" aria-hidden="true"><div class="finger"></div></div>
        <div class="title">Swipe Snow-Globe</div>
        <div class="hint">Swipe left & right or shake your device to wake the snow. Tap the globe to add a sparkle.</div>
      </div>
    </div>

    <div id="confetti" aria-hidden="true"></div>
    <div id="miniHint">Tip: flip your device to invert gravity</div>
  </div>

<script>
/* Minimal tutorial + full app
   - Swipe tutorial overlay removed on first activation
   - Confetti on first activation
   - Flip detection (upside-down inverts gravity)
   - Circular physics for image1 and confined particles
   - Uses your IPFS CIDs (background + image)
*/

// ---------- CONFIG ----------
const BG_CID = 'bafybeiepec62olvujw52tbntuaryuyoiofjjz7s246hmethykvgfbnls34';
const OBJ_CID = 'bafybeihnyoiyxsrzicx23funhiiwijfl55twsls6bsn4ypc2ybxyh7ucc4';
const PARTICLE_COUNT = 400;
const GRAVITY_BASE = 0.05; // base gravity magnitude
const OBJECT_HEAVIER = 1.5; // object heavier multiplier
const SWIRL_FORCE = 2.8;
const CONFETTI_PIECES = 42;

// ---------- DOM ----------
const canvas = document.getElementById('globe');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('globeWrap');
const tutorial = document.getElementById('tutorial');
const tcard = document.getElementById('tcard');
const confettiLayer = document.getElementById('confetti');

let W=0,H=0,CX=0,CY=0,R=0, DPR = Math.min(window.devicePixelRatio||1,2);
let started=false, tutorialShown=true, confettiActive=false;
let gravitySign = 1; // 1 normal, -1 inverted (upside-down)

// ---------- HiDPI & Resize ----------
function resize(){
  const cssW = wrap.clientWidth, cssH = wrap.clientHeight;
  DPR = Math.min(window.devicePixelRatio||1,2);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = cssW; H = cssH; CX = W/2; CY = H/2; R = Math.min(W,H)/2 - 8;
  // rescale particles/object if exist
  if (particles) for (let p of particles) p.ensureInside();
  if (snowObj) snowObj.rescale();
}
window.addEventListener('resize', resize);
resize();

// ---------- IMAGES ----------
const bg = new Image(); bg.crossOrigin='anonymous'; bg.src = 'https://ipfs.io/ipfs/' + BG_CID;
const objImg = new Image(); objImg.crossOrigin='anonymous'; objImg.src = 'https://ipfs.io/ipfs/' + OBJ_CID;

// ---------- UTIL ----------
function rand(min,max){return Math.random()*(max-min)+min}
function now(){return performance.now()}

// ---------- PARTICLES ----------
class Particle {
  constructor(initial=true){
    this.reset(initial);
  }
  reset(initial=true){
    const a = Math.random()*Math.PI*2;
    const r = Math.sqrt(Math.random()) * (R * 0.92);
    this.x = CX + Math.cos(a)*r;
    this.y = CY + Math.sin(a)*r;
    this.vx = (Math.random()-0.5)*0.5;
    this.vy = (Math.random()-0.5)*0.5;
    this.size = rand(0.8,2.2);
    this.alpha = rand(0.4,0.95);
    this.settled = false;
  }
  applyForce(fx,fy){ this.vx += fx; this.vy += fy; this.settled = false; }
  update(dt, g){
    if (!this.settled){
      this.vy += g * dt * 60;
      this.x += this.vx * dt * 60;
      this.y += this.vy * dt * 60;
      this.vx *= 0.987;
      this.vy *= 0.987;
    }
    this.ensureInside();
  }
  ensureInside(){
    const dx = this.x - CX, dy = this.y - CY;
    const d = Math.hypot(dx,dy);
    if (d > R - 1){
      const nx = dx/d, ny = dy/d;
      this.x = CX + nx * (R - 1);
      this.y = CY + ny * (R - 1);
      const dot = this.vx*nx + this.vy*ny;
      this.vx -= 1.5 * dot * nx;
      this.vy -= 1.5 * dot * ny;
      this.vx *= 0.88; this.vy *= 0.88;
      if (Math.abs(this.vx) < 0.01 && Math.abs(this.vy) < 0.01) this.settled = true;
    }
  }
  draw(){
    ctx.fillStyle = 'white';
    ctx.globalAlpha = this.alpha;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// ---------- SNOW OBJECT (circular physics body) ----------
class SnowObject {
  constructor(img){
    this.img = img;
    this.rescale();
    this.placeInitial();
  }
  rescale(){
    const scale = (Math.min(W,H) / 500) * 0.25;
    this.w = Math.max(8, this.img.width * scale);
    this.h = Math.max(8, this.img.height * scale);
    this.r = Math.max(this.w,this.h) * 0.45; // circular collision radius
  }
  placeInitial(){
    this.x = CX;
    this.y = CY - R * 0.45;
    this.vx = 0; this.vy = 0;
    this.angle = 0; this.angularVelocity = 0;
    this.settled = false;
    this.ensureInside();
  }
  applyForce(fx,fy){
    this.vx += fx;
    this.vy += fy;
    this.angularVelocity += (Math.random()-0.5) * 0.03;
    this.settled = false;
  }
  update(dt, g){
    if (!this.settled){
      this.vy += g * dt * 60 * OBJECT_HEAVIER;
      this.x += this.vx * dt * 60;
      this.y += this.vy * dt * 60;
      this.angle += this.angularVelocity * dt * 60;
      this.vx *= 0.96; this.vy *= 0.96;
      this.angularVelocity *= 0.98;
      if (Math.abs(this.angularVelocity) < 0.0008) this.angularVelocity = 0;
    }

    // soft circular collision with globe rim
    const dx = this.x - CX, dy = this.y - CY;
    const dist = Math.hypot(dx,dy);
    const maxDist = R - this.r;
    if (dist > maxDist){
      const nx = dx / dist, ny = dy / dist;
      const overlap = dist - maxDist;
      this.x -= nx * overlap * 0.5;
      this.y -= ny * overlap * 0.5;

      const vDotN = this.vx * nx + this.vy * ny;
      this.vx -= (1.2) * vDotN * nx;
      this.vy -= (1.2) * vDotN * ny;

      // tangential slide/ friction
      const tx = -ny, ty = nx;
      const vDotT = this.vx*tx + this.vy*ty;
      const friction = 0.86;
      this.vx = (this.vx - vDotT*tx) * friction + vDotT*tx;
      this.vy = (this.vy - vDotT*ty) * friction + vDotT*ty;

      // small rotational impulse
      this.angularVelocity += (Math.sign(vDotT) || 1) * 0.02;
    }

    // settle heuristic: near bottom hemisphere & very slow
    const bottomY = CY + R * 0.45;
    const speed = Math.hypot(this.vx, this.vy);
    if (!this.settled && this.y > bottomY && speed < 0.06 && Math.abs(this.angularVelocity) < 0.004){
      this.vx = 0; this.vy = 0; this.angularVelocity = 0; this.settled = true;
    }

    this.ensureInside();
  }
  ensureInside(){
    const dx = this.x - CX, dy = this.y - CY;
    const dist = Math.hypot(dx,dy);
    const maxD = Math.max(0, R - this.r);
    if (dist > maxD){
      const nx = dx/dist, ny = dy/dist;
      this.x = CX + nx * maxD;
      this.y = CY + ny * maxD;
      this.vx *= 0.5; this.vy *= 0.5;
    }
  }
  draw(){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.drawImage(this.img, -this.w/2, -this.h/2, this.w, this.h);
    ctx.restore();
  }
}

// ---------- CONFETTI ----------
function spawnConfetti(){
  confettiLayer.innerHTML = '';
  const colors = ['#ff4d6d','#ffd166','#6ee7b7','#9ad4ff','#b39cff'];
  for (let i=0;i<CONFETTI_PIECES;i++){
    const el = document.createElement('div');
    el.className = 'confetti-piece';
    const size = rand(6,12);
    el.style.width = size + 'px'; el.style.height = Math.round(size*1.4)+'px';
    el.style.left = (50 + rand(-20,20)) + '%';
    el.style.top = '40%';
    el.style.background = colors[i % colors.length];
    el.style.opacity = String(rand(0.9,1));
    el.style.transform = `translate3d(${rand(-60,60)}px,0,0) rotate(${rand(0,360)}deg)`;
    el.style.willChange = 'transform,opacity';
    confettiLayer.appendChild(el);

    // animate using requestAnimationFrame timeline
    const start = performance.now();
    const duration = rand(800,1400);
    (function animatePiece(now){
      const t = (now - start)/duration;
      if (t >= 1){
        el.style.opacity = '0';
        setTimeout(()=>el.remove(), 400);
        return;
      }
      const ease = Math.sin(t*Math.PI*0.5);
      const dx = rand(-120,120) * ease;
      const dy = ( -200 - rand(0,120)) * ease + (t*150);
      const rot = rand(0,360) * (1 - t);
      el.style.transform = `translate3d(${dx}px,${dy}px,0) rotate(${rot}deg)`;
      requestAnimationFrame(animatePiece);
    })(performance.now());
  }
  // clear after short time
  setTimeout(()=>confettiLayer.innerHTML = '', 1800);
}

// ---------- STATE ----------
let particles = [];
let snowObj = null;
let lastT = performance.now();
let gravity = GRAVITY_BASE * gravitySign;

// ---------- INIT ----------
function initParticles(){
  particles = [];
  for (let i=0;i<PARTICLE_COUNT;i++) particles.push(new Particle(true));
}
initParticles();

// start when images loaded
function startIfReady(){
  if (!bg.complete || !objImg.complete) { setTimeout(startIfReady,50); return; }
  resize(); // ensure geometry
  snowObj = new SnowObject(objImg);
  // nice initial settle
  snowObj.placeInitial();
  lastT = performance.now();
  requestAnimationFrame(loop);
}
bg.onload = startIfReady;
objImg.onload = startIfReady;

// ---------- INTERACTION (tutorial -> activation) ----------
function activateFromUser(){
  if (!started){
    started = true;
    if (tutorialShown){
      tutorialShown = false;
      // remove tutorial card
      tutorial.style.transition = 'opacity 300ms ease';
      tutorial.style.opacity = 0;
      setTimeout(()=> tutorial.remove(), 420);
      // confetti
      spawnConfetti();
    }
  }
}

// swipe detection for tutorial and swirl
let lastTouchX = null;
let swipeAccum = 0;
canvas.addEventListener('touchstart', (e)=>{ lastTouchX = e.touches[0].clientX; });
canvas.addEventListener('touchmove', (e)=>{
  const tx = e.touches[0].clientX;
  if (lastTouchX !== null){
    const dx = tx - lastTouchX;
    swipeAccum += Math.abs(dx) * 0.02;
    // small visual cue: scale tutorial card slightly on heavy swipe
    if (tutorialShown && swipeAccum > 0.4){
      tcard.style.transform = 'scale(0.98)';
    }
    if (swipeAccum > 1.0){
      // activate
      activateFromUser();
      applySwirl( SWIRL_FORCE * Math.min(2, swipeAccum) );
      swipeAccum = 0;
    }
  }
  lastTouchX = tx;
});
canvas.addEventListener('touchend', ()=>{ lastTouchX = null; swipeAccum = 0; });

// click/tap burst
canvas.addEventListener('click', (e)=>{
  activateFromUser();
  burstAt(e.clientX, e.clientY);
});

// device motion (shake) -> activation + swirl
function handleMotion(e){
  const a = e.accelerationIncludingGravity || e.acceleration || {x:0,y:0,z:0};
  const mag = Math.abs(a.x||0) + Math.abs(a.y||0) + Math.abs(a.z||0);
  if (mag > 20){
    activateFromUser();
    applySwirl( Math.min(6, (mag/8)) );
  }
}
if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
  // request permission on first user gesture
  const opt = { once:true };
  window.addEventListener('touchstart', ()=> {
    DeviceMotionEvent.requestPermission().then(resp=>{
      if (resp === 'granted') window.addEventListener('devicemotion', handleMotion);
    }).catch(()=>{/*ignore*/});
  }, opt);
} else {
  window.addEventListener('devicemotion', handleMotion);
}

// ---------- orientation flip detection (180 deg) ----------
function handleOrientation(e){
  // beta: front-to-back tilt [-180,180]
  const beta = e.beta || 0;
  // if device flipped so screen faces downward/upside-down, beta ~ +-180
  if (Math.abs(beta) > 140){
    // upside-down
    if (gravitySign !== -1){
      gravitySign = -1;
      gravity = GRAVITY_BASE * gravitySign;
      // give small impulse so particles react
      applyGlobalFlipImpulse();
    }
  } else {
    if (gravitySign !== 1){
      gravitySign = 1;
      gravity = GRAVITY_BASE * gravitySign;
      applyGlobalFlipImpulse();
    }
  }
}
if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
  // request permission on gesture similarly
  window.addEventListener('touchstart', ()=> {
    DeviceOrientationEvent.requestPermission().then(resp=>{
      if (resp === 'granted') window.addEventListener('deviceorientation', handleOrientation);
    }).catch(()=>{/*ignore*/});
  }, { once:true });
} else {
  window.addEventListener('deviceorientation', handleOrientation);
}

// fallback: if orientation events unavailable, try screen.orientation angle
function checkScreenAngle(){
  const angle = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
  if (Math.abs(angle - 180) < 20){
    if (gravitySign !== -1){ gravitySign = -1; gravity = GRAVITY_BASE * gravitySign; applyGlobalFlipImpulse(); }
  } else {
    if (gravitySign !== 1){ gravitySign = 1; gravity = GRAVITY_BASE * gravitySign; applyGlobalFlipImpulse(); }
  }
}
setInterval(checkScreenAngle, 1200);

// ---------- helpers ----------
function applySwirl(force){
  for (let p of particles) {
    const a = Math.random()*Math.PI*2;
    p.applyForce(Math.cos(a)*force, Math.sin(a)*force * 0.6);
  }
  if (snowObj){
    const a = Math.random()*Math.PI*2;
    snowObj.applyForce(Math.cos(a)*force*1.6, Math.sin(a)*force*1.6);
  }
}

// small burst at tap
function burstAt(cx,cy){
  for (let i=0;i<12;i++){
    const a = Math.random()*Math.PI*2;
    const idx = Math.floor(Math.random()*particles.length);
    particles[idx].x = cx + (Math.random()-0.5)*30;
    particles[idx].y = cy + (Math.random()-0.5)*30;
    particles[idx].applyForce(Math.cos(a)*3, Math.sin(a)*3 - Math.abs(gravitySign)*1.2);
  }
  spawnConfettiShort(cx,cy);
}

// flip impulse so things visibly reverse when inverted
function applyGlobalFlipImpulse(){
  for (let p of particles) p.applyForce((Math.random()-0.5)*0.8, -gravitySign * rand(0.6,1.6));
  if (snowObj) snowObj.applyForce((Math.random()-0.5)*1.6, -gravitySign * rand(0.9,2.6));
}

// minimal confetti at tap
function spawnConfettiShort(cx,cy){
  const colors = ['#ffd166','#ff4d6d','#9ad4ff','#b39cff','#6ee7b7'];
  for (let i=0;i<18;i++){
    const el = document.createElement('div');
    el.className = 'confetti-piece';
    const size = Math.round(rand(6,10));
    el.style.width = size + 'px';
    el.style.height = Math.round(size*1.4) + 'px';
    el.style.left = (cx/wrap.clientWidth*100) + '%';
    el.style.top = (cy/wrap.clientHeight*100) + '%';
    el.style.background = colors[i % colors.length];
    el.style.transform = `rotate(${rand(0,360)}deg)`;
    confettiLayer.appendChild(el);
    const start = performance.now();
    const dur = rand(600,1100);
    (function anim(now){
      const t = (now-start)/dur;
      if (t>1){ el.remove(); return; }
      const ease = Math.sin(t*Math.PI*0.5);
      const dx = rand(-80,80)*ease;
      const dy = rand(-200,-60)*(1-ease) + ease*(80);
      el.style.transform = `translate3d(${dx}px,${dy}px,0) rotate(${rand(0,360)}deg)`;
      requestAnimationFrame(anim);
    })(performance.now());
  }
}

// ---------- CONFETTI (big) ----------
function spawnConfetti(){
  spawnConfetti(); // placeholder - we use animated elements in spawnConfettiShort and earlier spawn
}

// ---------- ANIMATION LOOP ----------
let last = performance.now();
function loop(time){
  const dt = Math.min(0.033, (time - last)/1000);
  last = time;

  // update gravity based on sign
  const g = GRAVITY_BASE * gravitySign;

  // update particles
  for (let p of particles) p.update(dt, g);

  // update snow object
  if (snowObj) snowObj.update(dt, g);

  // render
  ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);

  // draw background clipped to globe
  ctx.save();
  ctx.beginPath();
  ctx.arc(CX, CY, R, 0, Math.PI*2);
  ctx.clip();
  if (bg.complete) ctx.drawImage(bg, 0, 0, W, H);
  ctx.restore();

  // draw snow object under particles
  if (snowObj) snowObj.draw();

  // draw particles above
  for (let p of particles) p.draw();

  // glass glare overlay
  ctx.save();
  ctx.globalAlpha = 0.22;
  const g1 = ctx.createRadialGradient(CX - R*0.35, CY - R*0.45, 5, CX, CY, R*1.2);
  g1.addColorStop(0, 'rgba(255,255,255,0.5)');
  g1.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = g1;
  ctx.beginPath(); ctx.arc(CX,CY,R,0,Math.PI*2); ctx.fill();
  ctx.restore();

  // chromatic rim
  ctx.save();
  ctx.lineWidth = Math.max(2, R*0.02);
  ctx.strokeStyle = 'rgba(120,160,255,0.28)';
  ctx.beginPath(); ctx.arc(CX,CY,R-2,0,Math.PI*2); ctx.stroke();
  ctx.strokeStyle = 'rgba(190,130,255,0.22)';
  ctx.lineWidth = Math.max(1, R*0.01); ctx.beginPath(); ctx.arc(CX,CY,R-4,0,Math.PI*2); ctx.stroke();
  ctx.restore();

  requestAnimationFrame(loop);
}

// ---------- start app after load ----------
function launch(){
  resize();
  initParticles();
  snowObj = new SnowObject(objImg);
  last = performance.now();
  requestAnimationFrame(loop);
}
function initParticles(){
  particles = [];
  for (let i=0;i<PARTICLE_COUNT;i++) particles.push(new Particle(true));
}
bg.onload = () => { if (objImg.complete) launch(); };
objImg.onload = () => { if (bg.complete) launch(); };
if (bg.complete && objImg.complete) launch();

</script>
</body>
</html>
