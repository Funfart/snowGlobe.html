<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snow Globe â€” OpenSea Embed</title>
<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#071226; }
  #globe-container { width:100%; height:100%; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="globe-container"></div>

<script type="module">
// -----------------------------
// Three.js + Postprocessing via CDN
// -----------------------------
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/controls/OrbitControls.js';
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/postprocessing/UnrealBloomPass.js';

// -----------------------------
// Setup scene, camera, renderer
// -----------------------------
const container = document.getElementById('globe-container');
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 100);
camera.position.set(0, 0.5, 2.2);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

// OrbitControls (optional, subtle movement)
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;
controls.enableDamping = true;
controls.minPolarAngle = Math.PI/2 - 0.8;
controls.maxPolarAngle = Math.PI/2 + 0.8;

// -----------------------------
// Lighting
// -----------------------------
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(2,3,2);
scene.add(dir);

// -----------------------------
// Globe geometry & glass
// -----------------------------
const globeGroup = new THREE.Group();
scene.add(globeGroup);

// inner globe
const innerGeo = new THREE.SphereGeometry(1,64,64);
const innerMat = new THREE.MeshStandardMaterial({
  color:0x041220,
  roughness:1,
  metalness:0
});
const innerMesh = new THREE.Mesh(innerGeo, innerMat);
innerMesh.scale.set(0.995,0.995,0.995);
globeGroup.add(innerMesh);

// glass overlay
const glassGeo = new THREE.SphereGeometry(1.01,64,64);
const glassMat = new THREE.MeshPhysicalMaterial({
  color:0xffffff,
  metalness:0,
  roughness:0.05,
  transmission:0.9,
  thickness:0.5,
  clearcoat:0.6,
  clearcoatRoughness:0.05,
  reflectivity:0.3,
  opacity:0.98,
  transparent:true
});
const glassMesh = new THREE.Mesh(glassGeo, glassMat);
globeGroup.add(glassMesh);

// -----------------------------
// Particle system (snow)
// -----------------------------
const PARTICLE_COUNT = 800; // lighter for mobile/iframe
const particleGeo = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);
for(let i=0;i<PARTICLE_COUNT;i++){
  const theta = Math.random() * Math.PI*2;
  const phi = Math.acos(Math.random()*2 -1);
  const r = 0.7 + Math.random()*0.3;
  positions[i*3] = r*Math.sin(phi)*Math.cos(theta);
  positions[i*3+1] = r*Math.cos(phi);
  positions[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
  velocities[i*3] = (Math.random()-0.5)*0.002;
  velocities[i*3+1] = -Math.random()*0.002;
  velocities[i*3+2] = (Math.random()-0.5)*0.002;
}
particleGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
particleGeo.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));

const particleMat = new THREE.PointsMaterial({
  color:0xffffff,
  size:0.02,
  transparent:true,
  opacity:0.8,
  blending:THREE.AdditiveBlending,
  depthWrite:false
});

const particles = new THREE.Points(particleGeo, particleMat);
globeGroup.add(particles);

// -----------------------------
// Postprocessing (bloom)
// -----------------------------
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene,camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight),0.9,0.4,0.1);
composer.addPass(bloom);

// -----------------------------
// Animation
// -----------------------------
function animate() {
  requestAnimationFrame(animate);

  // update particles
  const pos = particleGeo.getAttribute('position');
  const vel = particleGeo.getAttribute('velocity');
  for(let i=0;i<PARTICLE_COUNT;i++){
    const j=i*3;
    pos.array[j] += vel.array[j];
    pos.array[j+1] += vel.array[j+1];
    pos.array[j+2] += vel.array[j+2];

    // gravity
    vel.array[j+1] -= 0.0001;

    // reset if below globe bottom
    if(pos.array[j+1]<-1) {
      pos.array[j+1]=1;
      pos.array[j] = (Math.random()-0.5)*1.5;
      pos.array[j+2] = (Math.random()-0.5)*1.5;
      vel.array[j+1] = -Math.random()*0.002;
    }
  }
  pos.needsUpdate = true;

  // gentle globe rotation
  globeGroup.rotation.y += 0.001;

  composer.render();
}
animate();

// -----------------------------
// Resize
// -----------------------------
window.addEventListener('resize', ()=>{
  camera.aspect = container.clientWidth/container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
  composer.setSize(container.clientWidth, container.clientHeight);
});
</script>
</body>
</html>
